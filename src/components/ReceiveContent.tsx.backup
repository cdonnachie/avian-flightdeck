'use client'

import { useState, useEffect, useCallback } from 'react'
import { QrCode, Copy, CheckCircle, ExternalLink, ChevronLeft, ChevronRight } from 'lucide-react'
import { QRCodeSVG } from 'qrcode.react'
import { toast } from 'sonner'
import { StorageService } from '@/services/core/StorageService'
import { WalletData } from '@/services/wallet/WalletService'
import { useWallet } from '@/contexts/WalletContext'

// Import Shadcn UI components
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip'
import {
    Carousel,
    CarouselContent,
    CarouselItem,
    CarouselNext,
    CarouselPrevious
} from '@/components/ui/carousel'
import { Badge } from '@/components/ui/badge'

interface ReceiveContentProps {
    address: string
}

interface WalletDisplayItem {
    id?: number;
    address: string;
    name: string;
    isActive: boolean;
}

export default function ReceiveContent({ address }: ReceiveContentProps) {
    // Core states
    const [copied, setCopied] = useState(false);
    const [wallets, setWallets] = useState<WalletDisplayItem[]>([]);
    
    // SIMPLIFIED: Using direct state management for selected wallet index
    const [selectedWalletIndex, setSelectedWalletIndex] = useState<number>(0);
    
    // Flag to force selection to active wallet during CRUD operations
    const [forceActiveSelection, setForceActiveSelection] = useState(false);
    
    // UI states
    const [isLoading, setIsLoading] = useState(false);
    const [isSwitching, setIsSwitching] = useState(false);
    
    // Carousel API
    const [api, setApi] = useState<any>(null);
    
    const { reloadActiveWallet } = useWallet();
    
    // Selected address derived from selected index
    const selectedAddress = wallets[selectedWalletIndex]?.address || null;

    // Function to load all wallets with simplified selection logic
    const loadAllWallets = useCallback(async () => {
        try {
            setIsLoading(true);
            const allWallets = await StorageService.getAllWallets();

            // Format wallets for display
            const displayWallets = allWallets.map(wallet => ({
                id: wallet.id,
                address: wallet.address,
                name: wallet.name,
                isActive: wallet.isActive
            }));

            // Special case: No wallets
            if (displayWallets.length === 0) {
                setWallets([]);
                setSelectedWalletIndex(0);
                return;
            }
            
            // Update wallets state
            setWallets(displayWallets);
            
            // Now determine which wallet to select based on priority rules:
            
            // 1. If address prop is explicitly provided (from parent component)
            if (address) {
                const addressIndex = displayWallets.findIndex(w => w.address === address);
                if (addressIndex !== -1) {
                    setSelectedWalletIndex(addressIndex);
                    setForceActiveSelection(false);
                    return;
                }
            }
            
            // 2. When forcing active selection (after CRUD operations)
            if (forceActiveSelection) {
                const activeIndex = displayWallets.findIndex(w => w.isActive);
                if (activeIndex !== -1) {
                    setSelectedWalletIndex(activeIndex);
                    setForceActiveSelection(false); // Reset flag after using it
                    return;
                }
            }
            
            // 3. Try to use saved selection from localStorage if it exists
            try {
                const savedAddress = localStorage.getItem('user_selected_wallet');
                if (savedAddress) {
                    const savedIndex = displayWallets.findIndex(w => w.address === savedAddress);
                    if (savedIndex !== -1) {
                        setSelectedWalletIndex(savedIndex);
                        setForceActiveSelection(false);
                        return;
                    }
                }
            } catch (e) {
                // Silent handling of storage errors
            }
            
            // 4. Fall back to active wallet
            const activeIndex = displayWallets.findIndex(w => w.isActive);
            if (activeIndex !== -1) {
                setSelectedWalletIndex(activeIndex);
                return;
            }
            
            // 5. Last resort: first wallet
            setSelectedWalletIndex(0);
            
        } catch (error) {
            toast.error('Failed to load wallets', {
                description: error instanceof Error ? error.message : 'Unknown error'
            });
        } finally {
            setIsLoading(false);
        }
    }, [address, forceActiveSelection]);

    // Load all available wallets on component mount and when address changes
    useEffect(() => {
        // First, check if there's a user-selected wallet in localStorage
        try {
            const savedUserWalletAddress = localStorage.getItem('user_selected_wallet');
            if (savedUserWalletAddress) {
                // Only set this if we don't have a current selection
                if (!currentAddress) {
                    setCurrentAddress(savedUserWalletAddress);
                    // Mark that this is a user selection
                    userSelectedWalletRef.current = true;
                }
            }
        } catch (e) {
            // Silent handling of storage errors
        }
        
        loadAllWallets();
    }, [address, loadAllWallets, currentAddress])

    // Listen for wallet creation/import/deletion events
    useEffect(() => {
        // Function to reload wallets when a wallet is created or imported
        const handleWalletChanged = () => {
            // For creation/import, we want to select the new active wallet
            forceActiveSelectionRef.current = true;
            // Reset user selection flag - crucial for correct behavior
            userSelectedWalletRef.current = false;
            loadAllWallets();
        }
        
        // Function to handle wallet switch events
        const handleWalletSwitched = () => {
            // For wallet switching, we want to select the new active wallet
            forceActiveSelectionRef.current = true;
            // Reset user selection flag - only during explicit wallet switching
            userSelectedWalletRef.current = false;
            loadAllWallets();
        }

        // Special handler for wallet deletion that ensures we update the QR code
        const handleWalletDeleted = (event: Event) => {
            // Get the event details
            const detail = (event as CustomEvent).detail;
            const wasActive = detail?.wasActive || false;
            const deletedWalletAddress = detail?.address;
            
            // The deleted wallet was also the user's manual selection
            if (currentAddress && deletedWalletAddress && deletedWalletAddress === currentAddress) {
                // Clear manual selection since this wallet is gone
                userSelectedWalletRef.current = false;
            }
            
            // If the deleted wallet was active, we need to force selection of new active wallet
            if (wasActive) {
                forceActiveSelectionRef.current = true;
                // Reset user selection flag
                userSelectedWalletRef.current = false;
            }
            
            // Force a reload of all wallets
            loadAllWallets();
        }

        // Listen for relevant events
        window.addEventListener('wallet-created', handleWalletChanged)
        window.addEventListener('wallet-imported', handleWalletChanged)
        window.addEventListener('wallet-switched', handleWalletSwitched)
        window.addEventListener('wallet-deleted', handleWalletDeleted)

        // Cleanup listeners on unmount
        return () => {
            window.removeEventListener('wallet-created', handleWalletChanged)
            window.removeEventListener('wallet-imported', handleWalletChanged)
            window.removeEventListener('wallet-switched', handleWalletSwitched)
            window.removeEventListener('wallet-deleted', handleWalletDeleted)
        }
    }, [loadAllWallets, currentAddress])

    // Additional effect to log when wallets are loaded
    useEffect(() => {
        if (wallets.length > 0) {
            // We can add any additional logic here if needed
        }
    }, [wallets, currentAddress])
    
    // This effect handles initial carousel positioning and special cases
    useEffect(() => {
        // Only proceed if we have both API and wallets
        if (!api || !wallets.length) return;
        
        // First, determine which wallet should be selected
        let targetIndex = -1;
        let shouldPosition = false;
        let positionReason = '';
        
        // Check if this is a special case where we need to force the active wallet
        if (forceActiveSelectionRef.current) {
            // Find the active wallet
            const activeWallet = wallets.find(w => w.isActive);
            if (activeWallet) {
                targetIndex = wallets.findIndex(w => w.address === activeWallet.address);
                userSelectedWalletRef.current = false; // Reset user selection flag
                forceActiveSelectionRef.current = false; // Reset force flag
                shouldPosition = true; // Force positioning
                positionReason = 'FORCE_ACTIVE_SELECTION';
            }
        } 
        // If address prop is provided and exists, use it
        else if (address) {
            const addressIndex = wallets.findIndex(w => w.address === address);
            if (addressIndex !== -1) {
                targetIndex = addressIndex;
                userSelectedWalletRef.current = false; // This is an explicit selection
                shouldPosition = true; // Force positioning
                positionReason = 'ADDRESS_PROP_PROVIDED';
            }
        }
        // MOST IMPORTANT CASE: Check if user has manually selected a wallet (and it still exists)
        else if (userSelectedWalletRef.current && currentAddress) {
            const userIndex = wallets.findIndex(w => w.address === currentAddress);
            if (userIndex !== -1) {
                targetIndex = userIndex;
                shouldPosition = true; // CHANGE: Force positioning for user selection too
                positionReason = 'USER_MANUAL_SELECTION';
            }
        }
        
        // If no valid selection yet, fall back to active wallet or first wallet
        if (targetIndex === -1) {
            // First try to use active wallet
            const activeWallet = wallets.find(w => w.isActive);
            if (activeWallet) {
                targetIndex = wallets.findIndex(w => w.address === activeWallet.address);
                positionReason = 'FALLBACK_TO_ACTIVE';
            } else {
                // Fall back to first wallet
                targetIndex = 0;
                positionReason = 'FALLBACK_TO_FIRST';
            }
            
            // If we don't have a current address or it doesn't exist, force positioning
            if (!currentAddress || !wallets.some(w => w.address === currentAddress)) {
                shouldPosition = true;
                userSelectedWalletRef.current = false;
            }
        }
        
        if (targetIndex !== -1) {
            // Get the target wallet
            const targetWallet = wallets[targetIndex];
            
            // Update current address if needed
            if (targetWallet && currentAddress !== targetWallet.address) {
                setCurrentAddress(targetWallet.address);
                shouldPosition = true;
            }
            
            // Only position the carousel if needed (to respect manual scrolling)
            if (shouldPosition) {
                // Update the last selected index to prevent select event from firing
                lastSelectedIndexRef.current = targetIndex;
                
                // Position the carousel with a retry mechanism
                const positionCarousel = () => {
                    try {
                        // First, check if we're already at the right position
                        const currentPos = api.selectedScrollSnap();
                        if (currentPos !== targetIndex) {
                            // CHANGE: Force positioning with animation first for better UX
                            api.scrollTo(targetIndex, true);
                            
                            // Double-check the position after a short delay
                            setTimeout(() => {
                                try {
                                    const newPos = api.selectedScrollSnap();
                                    if (newPos !== targetIndex) {
                                        // Try once more without animation
                                        api.scrollTo(targetIndex, false);
                                        
                                        // Final verification
                                        setTimeout(() => {
                                            try {
                                                const finalPos = api.selectedScrollSnap();
                                                // Silent handling of final position check
                                            } catch (e) {
                                                // Silent handling
                                            }
                                        }, 150);
                                    }
                                } catch (e) {
                                    // Silent error handling
                                }
                            }, 150);
                        }
                    } catch (error) {
                        // If positioning fails, retry after a delay
                        setTimeout(() => {
                            try {
                                api.scrollTo(targetIndex, false);
                            } catch (e) {
                                // Silent error handling
                            }
                        }, 150);
                    }
                };
                
                // Delay positioning slightly to ensure API is fully initialized
                setTimeout(positionCarousel, 50);
            }
        }
    }, [api, wallets, address, currentAddress]);

    // Scroll to the selected wallet when the currentAddress changes
    // THIS IS THE MOST CRITICAL EFFECT FOR MANUAL WALLET SELECTION
    useEffect(() => {
        if (api && wallets.length > 0 && currentAddress) {
            const index = wallets.findIndex(w => w.address === currentAddress)
            if (index !== -1) {
                // Always update the reference first to prevent select event from firing
                lastSelectedIndexRef.current = index;
                
                // FORCE POSITIONING: Always reposition the carousel when the address changes
                // This is crucial for the fix - we're taking a more direct approach
                
                // First check current position
                try {
                    // Get current position to check if we need to move
                    const currentPos = api.selectedScrollSnap();
                    
                    if (currentPos !== index) {
                        // First attempt - with animation
                        api.scrollTo(index, true);
                        
                        // Verify immediately with multiple retries
                        const verifyPosition = () => {
                            try {
                                if (api.selectedScrollSnap() !== index) {
                                    // Second attempt - without animation for reliability
                                    api.scrollTo(index, false);
                                    
                                    // Final verification after a delay
                                    setTimeout(() => {
                                        try {
                                            if (api.selectedScrollSnap() !== index) {
                                                // Last attempt - direct force
                                                api.scrollTo(index, false);
                                            }
                                        } catch (e) {
                                            // Silent handling
                                        }
                                    }, 150);
                                }
                            } catch (e) {
                                // Silent handling
                            }
                        };
                        
                        // Schedule verification after animation would complete
                        setTimeout(verifyPosition, 100);
                    }
                } catch (e) {
                    // If getting position fails, just force it directly
                    try {
                        api.scrollTo(index, false);
                    } catch (err) {
                        // Silent handling
                    }
                }
            }
        }
    }, [api, currentAddress, wallets])
    
    // Enhanced effect to handle carousel select events (user dragging or clicking carousel)
    useEffect(() => {
        if (!api || !wallets.length) return;
        
        // This handler is called when carousel finishes scrolling and settles on a slide
        const onSelect = () => {
            try {
                const selectedIndex = api.selectedScrollSnap();
                
                // Protect against out-of-bounds access
                if (selectedIndex < 0 || selectedIndex >= wallets.length) return;

                // CRUCIAL FIX: We need to check if this is a deliberate user action vs. programmatic scroll
                // We now need to distinguish between these cases more carefully
                
                // First capture the current index for comparison
                const previousIndex = lastSelectedIndexRef.current;
                
                // If index changed AND not a programmatic update (as tracked by lastSelectedIndexRef)
                const isUserAction = previousIndex !== selectedIndex;
                
                if (isUserAction) {
                    // DIRECT APPROACH: When user manually interacts with carousel
                    
                    // 1. Cancel any force selection that might be pending
                    forceActiveSelectionRef.current = false;
                    
                    // 2. Mark this as an explicit user selection
                    userSelectedWalletRef.current = true;
                    
                    // 3. Update the reference to the current position
                    lastSelectedIndexRef.current = selectedIndex;
                    
                    // 4. Capture the selected wallet
                    const selectedWallet = wallets[selectedIndex];
                    
                    // 5. Update the current address if needed
                    if (selectedWallet && selectedWallet.address !== currentAddress) {
                        setCurrentAddress(selectedWallet.address);
                        
                        // 6. Persist to localStorage for survival across reloads
                        try {
                            localStorage.setItem('user_selected_wallet', selectedWallet.address);
                        } catch (e) {
                            // Silent handling
                        }
                    }
                }
            } catch (error) {
                // Silently handle any errors with the carousel API
            }
        };

        // Register the event listener
        api.on('select', onSelect);

        return () => {
            // Clean up event listener when component unmounts or API changes
            try {
                api.off('select', onSelect);
            } catch (error) {
                // Handle API cleanup errors silently
            }
        };
    }, [api, wallets, currentAddress]);

    const handleSwitchWallet = async (walletAddress: string) => {
        try {
            // Find the wallet ID from its address
            const wallet = wallets.find(w => w.address === walletAddress)
            if (!wallet) {
                toast.error('Wallet not found')
                return
            }

            setIsSwitching(true)

            // Use the same function from StorageService that WalletManager uses
            const success = await StorageService.switchToWallet(wallet.id!)

            if (success) {
                // This is an explicit activation, so force selection of active wallet next time
                forceActiveSelectionRef.current = true;
                
                // Reset user manual selection flag
                userSelectedWalletRef.current = false;
                
                // Update the current address to match the newly active wallet
                setCurrentAddress(walletAddress)

                // Find the index of this wallet in the carousel
                const walletIndex = wallets.findIndex(w => w.address === walletAddress)

                // If we have the carousel API and found the index, update the carousel position
                if (api && walletIndex !== -1) {
                    // Update the last selected index to prevent select event from firing again
                    lastSelectedIndexRef.current = walletIndex

                    // Simple position attempt with retry
                    try {
                        api.scrollTo(walletIndex, true);
                        
                        // Verify position after a delay
                        setTimeout(() => {
                            try {
                                if (api.selectedScrollSnap() !== walletIndex) {
                                    // Try once more without animation
                                    api.scrollTo(walletIndex, false);
                                }
                            } catch (e) {
                                // Silent error handling
                            }
                        }, 100);
                    } catch (e) {
                        // If the first attempt fails, try once more after a delay
                        setTimeout(() => {
                            try {
                                api.scrollTo(walletIndex, false);
                            } catch (error) {
                                // Silent handling
                            }
                        }, 100);
                    }
                }

                // Update the last active wallet to prevent false balance change notifications
                localStorage.setItem('last_active_wallet', wallet.address);

                // Update the global wallet context
                await reloadActiveWallet()
                
                // Reload all wallets to get updated active status
                await loadAllWallets()

                // Dispatch wallet-switched event to notify other components
                window.dispatchEvent(new CustomEvent('wallet-switched'))

                toast.success('Wallet activated', {
                    description: `${wallet.name} is now your active wallet`
                })
            }
        } catch (error) {
            toast.error('Failed to switch wallet', {
                description: error instanceof Error ? error.message : 'Unknown error'
            })
        } finally {
            setIsSwitching(false)
        }
    }

    const copyToClipboard = async (addressToCopy = currentAddress) => {
        try {
            if (!addressToCopy) return;

            await navigator.clipboard.writeText(addressToCopy)
            toast.success('Address copied!', {
                description: 'Avian address copied to clipboard'
            })
            setCopied(true)
            setTimeout(() => setCopied(false), 2000)
        } catch (error) {
            toast.error('Failed to copy address', {
                description: error instanceof Error ? error.message : 'Unknown error'
            })
        }
    }



    if (isLoading) {
        return (
            <Card className="border-none shadow-none">
                <CardHeader className="text-center space-y-2">
                    <div className="flex justify-center items-center">
                        <QrCode className="w-6 h-6 text-primary" />
                    </div>
                    <CardTitle>
                        Receive AVN
                    </CardTitle>
                    <Alert className="bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800">
                        <AlertDescription className="text-yellow-600 dark:text-yellow-400 text-sm">
                            ⚠️ Do not keep large amounts in your wallet
                        </AlertDescription>
                    </Alert>
                </CardHeader>
                <CardContent className="space-y-6">
                    <div className="flex flex-col items-center justify-center space-y-4">
                        <div className="relative w-48 h-48 sm:w-56 sm:h-56 bg-muted rounded-md animate-pulse flex items-center justify-center">
                            <QrCode className="w-16 h-16 text-muted-foreground/30" />
                        </div>
                        <div className="w-full max-w-md space-y-2">
                            <div className="h-4 bg-muted rounded animate-pulse"></div>
                            <div className="h-10 bg-muted rounded animate-pulse"></div>
                        </div>
                        <p className="text-muted-foreground">Loading wallets...</p>
                    </div>
                </CardContent>
            </Card>
        )
    }

    // Modified logic to ensure we properly detect when a wallet is available
    // Check for both currentAddress AND address prop from parent component
    if ((!currentAddress && !address) || wallets.length === 0) {
        return (
            <Card className="border-none shadow-none">
                <CardHeader className="text-center space-y-2">
                    <div className="flex justify-center items-center">
                        <QrCode className="w-6 h-6 text-primary" />
                    </div>
                    <CardTitle>
                        Receive AVN
                    </CardTitle>
                </CardHeader>
                <CardContent className="p-6 text-center space-y-4">
                    <div className="bg-muted p-6 rounded-lg flex flex-col items-center space-y-2">
                        <QrCode className="w-12 h-12 text-muted-foreground/50" strokeWidth={1} />
                        <h3 className="font-medium text-lg">No Wallet Address</h3>
                        <p className="text-muted-foreground max-w-xs">
                            You need to create or import a wallet to receive AVN.
                        </p>
                        <Button
                            className="mt-2"
                            variant="outline"
                            onClick={() => {
                                // Open the wallet manager via application-level state
                                const event = new CustomEvent('openWalletManager', { detail: { tab: 'create' } });
                                window.dispatchEvent(event);
                            }}
                        >
                            Create Wallet
                        </Button>
                    </div>
                </CardContent>
            </Card>
        )
    }

    return (
        <Card className="border-none shadow-none">
            <CardHeader className="text-center space-y-2">
                <div className="flex justify-center items-center">
                    <QrCode className="w-6 h-6 text-primary" />
                </div>
                <CardTitle>
                    Payment Address
                </CardTitle>
                <Alert className="bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800">
                    <AlertDescription className="text-yellow-600 dark:text-yellow-400 text-sm">
                        ⚠️ Do not keep large amounts in your wallet
                    </AlertDescription>
                </Alert>
            </CardHeader>

            <CardContent className="space-y-6">
                {/* QR Code Carousel */}
                {wallets.length > 1 ? (
                    <div className="relative">
                        <Carousel
                            className="w-full max-w-xs mx-auto"
                            setApi={(newApi) => {
                                // Important: Only set API when it's really changed
                                // This prevents unnecessary re-renders
                                if (newApi && (!api || api !== newApi)) {
                                    setApi(newApi);
                                    
                                    // When API is first initialized, ensure the carousel positions properly
                                    // This is crucial for initial wallet selection
                                    if (currentAddress) {
                                        const targetIndex = wallets.findIndex(w => w.address === currentAddress);
                                        if (targetIndex !== -1) {
                                            // Wait a tick to ensure API is ready
                                            setTimeout(() => {
                                                try {
                                                    // Update reference to prevent select event handling
                                                    lastSelectedIndexRef.current = targetIndex;
                                                    // Force position to correct wallet - DIRECT APPROACH
                                                    newApi.scrollTo(targetIndex, false);
                                                    
                                                    // Double-verify after a delay
                                                    setTimeout(() => {
                                                        if (newApi.selectedScrollSnap() !== targetIndex) {
                                                            // Force once more
                                                            newApi.scrollTo(targetIndex, false);
                                                        }
                                                    }, 150);
                                                } catch (e) {
                                                    // Silent handling of API errors
                                                }
                                            }, 50);
                                        }
                                    }
                                }
                            }}
                            opts={{
                                // Simplify carousel options to ensure more reliable positioning
                                align: 'center',
                                dragFree: false,
                                loop: false,
                                skipSnaps: false,
                                containScroll: false, // Changed to prevent containment issues
                                // Key fix: We need an explicit start index calculation
                                startIndex: userSelectedWalletRef.current && currentAddress ? 
                                           wallets.findIndex(w => w.address === currentAddress) : // User selection
                                           forceActiveSelectionRef.current ? 
                                               wallets.findIndex(w => w.isActive) : // Forced active wallet
                                               wallets.findIndex(w => w.address === currentAddress) || 
                                               wallets.findIndex(w => w.isActive) || 0 // Fallback
                            }}
                        >
                            <CarouselContent>
                                {wallets.map((wallet) => (
                                    <CarouselItem key={wallet.address}>
                                        <div className="p-1">
                                            <Card
                                                className={
                                                    wallet.isActive
                                                        ? "bg-background p-3 shadow-sm border ring-2 ring-primary"
                                                        : "bg-background p-3 shadow-sm border"
                                                }
                                                onClick={() => {
                                                    // Skip if already on this wallet to prevent loops
                                                    if (currentAddress === wallet.address) return;

                                                    // Find the index of this wallet
                                                    const index = wallets.findIndex(w => w.address === wallet.address);

                                                    if (index !== -1 && api) {
                                                        // IMPORTANT: Explicitly cancel any force selection that might be pending
                                                        forceActiveSelectionRef.current = false;
                                                        
                                                        // Mark that a user selection was made - this is what allows manual selection to work
                                                        userSelectedWalletRef.current = true;
                                                        
                                                        // Update the last selected index to prevent select event from firing again
                                                        lastSelectedIndexRef.current = index;

                                                        // First update address state
                                                        setCurrentAddress(wallet.address);
                                                        
                                                        // Store in localStorage to persist selection across reloads
                                                        try {
                                                            localStorage.setItem('user_selected_wallet', wallet.address);
                                                        } catch (e) {
                                                            // Silently handle storage errors
                                                        }
                                                        
                                                        // Debounce the carousel positioning to prevent race conditions
                                                        // Use a short timeout to ensure state updates complete first
                                                        setTimeout(() => {
                                                            try {
                                                                // Position with animation for better UX
                                                                api.scrollTo(index, true);
                                                                
                                                                // Verify positioning after a longer delay
                                                                setTimeout(() => {
                                                                    try {
                                                                        if (api.selectedScrollSnap() !== index) {
                                                                            // Try once more without animation
                                                                            api.scrollTo(index, false);
                                                                            
                                                                            // Final verification
                                                                            setTimeout(() => {
                                                                                try {
                                                                                    if (api.selectedScrollSnap() !== index) {
                                                                                        // Last resort: force scroll without animation
                                                                                        api.scrollTo(index, false);
                                                                                    }
                                                                                } catch (err) {
                                                                                    // Silent handling
                                                                                }
                                                                            }, 100);
                                                                        }
                                                                    } catch (e) {
                                                                        // Silent error handling
                                                                    }
                                                                }, 150);
                                                            } catch (e) {
                                                                // If first try fails, retry after a delay
                                                                setTimeout(() => {
                                                                    try {
                                                                        api.scrollTo(index, false);
                                                                    } catch (err) {
                                                                        // Silent handling
                                                                    }
                                                                }, 150);
                                                            }
                                                        }, 10); // Short delay to ensure state updates
                                                    }
                                                }}
                                                style={{ cursor: 'pointer' }}
                                            >
                                                <CardContent className="flex flex-col items-center p-3 space-y-2">
                                                    <div className="w-48 h-48 sm:w-56 sm:h-56 flex items-center justify-center bg-white">
                                                        <QRCodeSVG
                                                            value={wallet.address}
                                                            size={224}
                                                            bgColor="#FFFFFF"
                                                            fgColor="#1f2937"
                                                            level="L"
                                                        />
                                                    </div>
                                                    <div className="flex flex-col items-center gap-2 mt-2">
                                                        <div className="flex items-center gap-2">
                                                            <div className="text-sm font-medium truncate max-w-[150px]">{wallet.name}</div>
                                                            {wallet.isActive && (
                                                                <Badge variant="outline" className="bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300 border-green-200 dark:border-green-700">
                                                                    Active
                                                                </Badge>
                                                            )}
                                                            {!wallet.isActive && (
                                                                <Badge
                                                                    variant="outline"
                                                                    className="cursor-pointer hover:text-white hover:bg-accent"
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        if (!isSwitching) {
                                                                            handleSwitchWallet(wallet.address);
                                                                        }
                                                                    }}
                                                                >
                                                                    {isSwitching ? 'Switching...' : 'Set Active'}
                                                                </Badge>
                                                            )}

                                                        </div>
                                                    </div>
                                                </CardContent>
                                            </Card>
                                        </div>
                                    </CarouselItem>
                                ))}
                            </CarouselContent>
                            <CarouselPrevious className="-left-3 h-8 w-8 md:-left-5 md:h-10 md:w-10" />
                            <CarouselNext className="-right-3 h-8 w-8 md:-right-5 md:h-10 md:w-10" />
                        </Carousel>

                        <div className="mt-2 flex flex-col items-center space-y-2">
                            <p className="text-xs text-muted-foreground">Swipe or use arrows to view all wallet addresses</p>
                            <div className="flex flex-wrap justify-center gap-1 mt-1">
                                {wallets.map((wallet, idx) => (
                                    <Button
                                        key={wallet.address}
                                        size="sm"
                                        variant={currentAddress === wallet.address ? "default" : "outline"}
                                        className="h-7 px-2 min-w-7 rounded-full"
                                        onClick={() => {
                                            // Skip if already on this wallet to prevent loops
                                            if (currentAddress === wallet.address) return;

                                            // IMPORTANT: Explicitly cancel any force selection that might be pending
                                            forceActiveSelectionRef.current = false;
                                                        
                                            // Mark that a user selection was made - this is what allows manual selection to work
                                            userSelectedWalletRef.current = true;
                                            
                                            // Update the last selected index to prevent select event from firing again
                                            lastSelectedIndexRef.current = idx;

                                            if (api) {
                                                try {
                                                    // First update address state
                                                    setCurrentAddress(wallet.address);
                                                    
                                                    // Store in localStorage to persist selection across reloads
                                                    try {
                                                        localStorage.setItem('user_selected_wallet', wallet.address);
                                                    } catch (e) {
                                                        // Silently handle storage errors
                                                    }
                                                    
                                                    // Debounce the carousel positioning to prevent race conditions
                                                    // Use a short timeout to ensure state updates complete first
                                                    setTimeout(() => {
                                                        try {
                                                            // Position with animation for better UX
                                                            api.scrollTo(idx, true);
                                                            
                                                            // Verify positioning after a delay
                                                            setTimeout(() => {
                                                                try {
                                                                    if (api.selectedScrollSnap() !== idx) {
                                                                        // Try once more without animation
                                                                        api.scrollTo(idx, false);
                                                                        
                                                                        // Verify once more after a delay
                                                                        setTimeout(() => {
                                                                            try {
                                                                                if (api.selectedScrollSnap() !== idx) {
                                                                                    // Last attempt: force position
                                                                                    api.scrollTo(idx, false);
                                                                                }
                                                                            } catch (e) {
                                                                                // Silent handling
                                                                            }
                                                                        }, 100);
                                                                    }
                                                                } catch (e) {
                                                                    // Silent handling
                                                                }
                                                            }, 150);
                                                        } catch (e) {
                                                            // If first attempt fails, retry after a delay
                                                            setTimeout(() => {
                                                                try {
                                                                    api.scrollTo(idx, false);
                                                                } catch (err) {
                                                                    // Silent handling
                                                                }
                                                            }, 150);
                                                        }
                                                    }, 10); // Short delay to ensure state updates
                                                } catch (error) {
                                                    toast.error('Error during wallet selection', {
                                                        description: error instanceof Error ? error.message : 'Unknown error'
                                                    });
                                                }
                                            }
                                        }}
                                        aria-label={`Select wallet ${idx + 1} (${wallet.name})`}
                                    >
                                        {idx + 1}
                                    </Button>
                                ))}
                            </div>
                        </div>
                    </div>
                ) : (
                    <div className="flex justify-center">
                        <Card className="bg-background p-3 shadow-sm border">
                            <div className="w-48 h-48 sm:w-56 sm:h-56 flex items-center justify-center">
                                <QRCodeSVG
                                    value={currentAddress || ""}
                                    size={224}
                                    bgColor="#FFFFFF"
                                    fgColor="#1f2937"
                                    level="L"
                                // Remove deprecated includeMargin prop
                                />
                            </div>
                        </Card>
                    </div>
                )}

                {/* Address */}
                <div>
                    <h3 className="text-base font-medium mb-3 text-center">
                        Your Avian Address
                        {wallets.length > 1 && (
                            <span className="ml-2 text-sm text-muted-foreground">
                                ({wallets.find(w => w.address === currentAddress)?.name || 'Unknown wallet'})
                            </span>
                        )}
                    </h3>
                    <div className="flex items-center bg-muted rounded-lg p-3">
                        <div className="flex-1 text-sm font-mono break-all">
                            {currentAddress}
                        </div>

                        <TooltipProvider>
                            <Tooltip>
                                <TooltipTrigger asChild>
                                    <a
                                        href={`https://explorer.avn.network/address/?address=${currentAddress}`}
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        className="text-primary hover:text-primary/80 flex"
                                        aria-label="Open address in Avian Explorer (opens in new tab)"
                                    >
                                        <ExternalLink className="w-4 h-4" />
                                    </a>
                                </TooltipTrigger>
                                <TooltipContent>
                                    View on Explorer
                                </TooltipContent>
                            </Tooltip>
                        </TooltipProvider>

                        <TooltipProvider>
                            <Tooltip>
                                <TooltipTrigger asChild>
                                    <Button
                                        onClick={() => copyToClipboard()}
                                        variant="ghost"
                                        size="icon"
                                        className="h-8 w-8 ml-1 rounded-full"
                                    >
                                        {copied ? (
                                            <CheckCircle className="w-4 h-4 text-green-500" />
                                        ) : (
                                            <Copy className="w-4 h-4" />
                                        )}
                                    </Button>
                                </TooltipTrigger>
                                <TooltipContent>
                                    {copied ? 'Copied!' : 'Copy Address'}
                                </TooltipContent>
                            </Tooltip>
                        </TooltipProvider>
                    </div>
                </div>

                {/* Instructions */}
                <div className="text-center text-sm text-muted-foreground space-y-1">
                    <p>Share this address to receive AVN payments</p>
                    <p>Each transaction will be visible on the blockchain</p>
                </div>
            </CardContent>
        </Card>
    )
}
